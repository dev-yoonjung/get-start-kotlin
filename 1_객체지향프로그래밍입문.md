# 1. 비용

<img width="538" height="380" alt="스크린샷 2025-10-14 오전 11 59 03" src="https://github.com/user-attachments/assets/f74e057d-7d7e-4b84-85ec-1699f1ea054b" />

y축: 비용/코드라인 수 <br/>
x축: 릴리즈버전 <br/>
<br/>
즉, 운영을 오래하면 오래할 수록 개발에 대한 비용이 커짐 <br/>
이 그래프만 봐도 이해가 되는게, 한 줄 바꾸는데도 영향도 파악을 해야하고 기존에 운영되었던 로직이 문제 없이 잘 돌아가야하니까 단순 개발끝난다고 다가 아니긴 하지ㅎ

<img width="671" height="395" alt="스크린샷 2025-10-14 오후 12 02 00" src="https://github.com/user-attachments/assets/16f26739-bb41-4e5d-b909-70e37be83d90" />

그런데, 릴리즈 5버전부터 제품에 추가되는 기능은 거의 차이가 없음 <br/>
이래서 고여가는건가?

그리고 비슷한 로직이 한 곳에만 있는게 아니라 여러군데에 비슷한 로직이 여기저기 자기복제 되어 흩뿌려져 있음<br/>
(도대체 왜 그러는지 이해가 안됨.. 지금 프로젝트 하는데도 수행사 그렇게 개발하고 있음 개빡침)<br/>
변경되어야 하는 로직이 여기저기 양산되어 있으면 그걸 찾고 고쳐야 함<br/>
그러면 또 시간이 걸림

```java
if ((acc.getMembership() == REGULAR || acc.getMembership() == PRO) && acc.getExpDate().isAfter(now)) {
    // 유료회원기능
}
```
이런 것도 코드 분석하는데, 시간이 오래걸림<br/>
심지어 저런건 사내에서 소나큐브 설정해놓으면 소나큐브가 복잡하다고 갈!함<br/>
<img width="294" height="317" alt="스크린샷 2025-10-14 오후 12 12 50" src="https://github.com/user-attachments/assets/bfa393d4-8286-4be6-a5b5-e0c1a7ad6c82" />

## 비용이 증가하는 주요 원인
1. 코드 분석 시간 증가
2. 코드 변경 시간 증가

특히, 분석하는 시간이 증가하는 것 같음<br/>
요즘 나조차도 코드 난독 생기는 것 같고, 코드가 깔끔하지 않으면 쳐다보기도 싫음<br/>

## 소프트웨어의 가치: 변화

<img width="869" height="348" alt="스크린샷 2025-10-14 오후 12 18 01" src="https://github.com/user-attachments/assets/427f2a7a-c389-416b-9dde-d2a736a8cd7c" />

진짜 너무너무 멋있는 말인 것 같음

## 비용과 변화
낮은 비용으로 변화할 수 있어야 함

### 이를 위한 방법

#### 패러다임
- 객체지향
- 함수형
- 리액티브

#### 코드, 설계, 아키텍처
- DRY
- TDD
- SOLID
- DDD
- 클린아키텍처
- MSA

#### 업무프로세스 / 문화
- 애자일
- DevOps

## 객체지향은 어떻게 비용을 낮춰주는가
- 캡슐화
- 다형성(추상화)
로 비용을 낮춰줌

# 2. 객체 

## 객체지향은 뭐고 절차지향은 뭔데?

- 절차지향: 데이터를 여러 프로시저가 공유하는 방식
    - 장점: 쉬움
    - 단점: 시간이 지날수록 구조를 복잡하게 만들고, 수정을 어렵게 만듦. 

대부분의 사람들은 객체지향언어인 자바로 절차지향으로 개발하고 있는 거 아닐까? 라는 생각을 자주 함

- 객체지향: 데이터와 프로시저를 객체라는 단위로 묶음
  - A라는 객체가 B객체의 데이터를 바로 접근하는 것을 막음
  - 객체는 프로시저를 통해 외부에 기능을 제공함
      - 객체와 객체는 서로의 프로시저를 호출하는 방식으로 연결을 함
  - 단점: 처음엔 어려움
      - 데이터와 프로시저를 알맞게 묶어야 하기 때문에 이 과정이 어려울 수 있음
  - 장점: 코드를 수정하기가 수월함
 
## 객체란?

### 객체의 핵심
그 객체가 어떠한 기능을 제공하는가?에 있음<br/>
객체는 제공하는 기능으로 정의하지, 내부적으로 가진 필드(데이터)로 정의하지 않음

#### 예시
- 회원객체
    - 암호 변경하기 기능
    - 차단 여부 확인하기 기능
- 소리 제어기
    - 소리 크기 증가하기 기능
    - 소리 크기 감소하기 기능
 
기능을 제공한다는 것은 그 기능을 사용한다는 것임ㅇㅇ<br/>
그 기능을 사용하려면 설명서가 필요함 -> 그게 바로 기능 명세임

### 기능명세
메서드(오퍼레이션)를 이용하여 기능을 명세함<br/>
이름, 파라미터, 결과로 구성

```java
public class VolumeController {

    public void increase(int inc) {
        ....
    }

    public void decrease(int inc) {
        ....
    }

    public int volume() {
        ....
    }

}
```

## 객체와 객체
객체와 객체는 기능을 사용해서 연결함<br/>
► 기능 사용 == 메서드 호출

```java
VolumeController volCont = new VolumeController();
volCont.increase(4);
volCont.decrease(3);
int currentVol = volCont.volume();
```
특정 객체 안에서 VolumeController 객체의 기능을 사용하는 모습

## 메시지
객체지향언어에서 `메시지`라는 용어를 종종 사용함<br/>
객체와 객체가 서로 상호작용하는 것 == 메시지를 주고 받는다 <br/>
라고 표현함

예)
- 메세드를 호출하는것도 메시지
- 리턴하는것도 메시지
- exception도 메시지

<img width="847" height="347" alt="스크린샷 2025-10-14 오후 3 56 23" src="https://github.com/user-attachments/assets/e5a9c39b-249d-4fba-ae0b-df0b83fd5dc1" />

## 그러면 이것도 객체일까?

```java
public class Member {

    private String name;
    private String id;

    public void setName(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getId() {
        return id;
    }

}
```

이 코드는 바로 데이터에 접근하는 기능만 있고, 아무런 기능이 존재하지 않음 <br/>
고로 이 클래스는 객체라기보단 `데이터클래스`임

# 3. ⭐️ 캡슐화 ⭐️

## 캡슐화란?

데이터와 데이터와 관련된 기능을 묶는 것을 `캡슐화`라 함<br/>
그런데, 캡슐화할 때 객체가 기능을 어떻게 구현했는지는 외부에 감춤<br/>
- 실제 구현에 사용된 데이터가 어떤 타입인지, 그 데이터의 값을 어떻게 사용하는지, 구현과 관련된 상세 내용을 위부에 감춤
최근에는 캡슐화 속에 정보 은닉의 의미를 표현하는 경우가 많음

## 캡슐화 왜함?
외부에 영향 없이 객체 내부 구현을 변경할 수 있음

### 캡슐화 하지 않으면
```java
// ASIS
if (acc.getMembership() == REGULAR && acc.getExpDate().isAfter(now())) {
    ...정회원 가능
}

// 5년 이상 사용자 일부 기능 정회원 혜택 1개월 무상 제공 요구사항 추가

// TOBE
if (acc.getMembership() == REGULAR &&
    (
        (acc.getServiceDate().isAfter(fiveYearAgo) && ac.getExpDate().isAfter(now())) ||
        (acc.getServiceDate().isBefore(fiveYearAgo) && addMonth(acc.getExpDate()).isAfter(now()))
    )
) {
    ...정회원 가능
}
```
복잡하다...

<img width="801" height="470" alt="스크린샷 2025-10-14 오후 4 19 16" src="https://github.com/user-attachments/assets/247799e7-555b-476d-9528-3c0620a389c9" />

### 캡슐화를 하면

기능을 제공하고 구현 상세를 감춤

```java
// ASIS
if (acc.hasRegularPermission()) {
    ...정회원 기능
}

public class Account {

    private Membership membership;
    private Date expDate;

    public boolean hasRegularPermission() {
        return membership == REGULAR && expDate.isAfter(now());
    }

}

// 5년 이상 사용자 일부 기능 정회원 혜택 1개월 무상 제공 요구사항 추가

// TOBE
if (acc.hasRegularPermission()) { // 여기는 수정할 필요가 없음
    ...정회원 기능
}

public class Account {

    ...

    public boolean hasRegularPermission() { // 여기만 수정됨
        return membership == REGULAR && (
            expDate.isAfter(now()) ||
            (serviceDate.isBefore(fiveYearAgo()) && addMonth(expDate).isAfter(now()))  
        );
    }

}
```
 
<img width="927" height="529" alt="스크린샷 2025-10-14 오후 4 29 02" src="https://github.com/user-attachments/assets/fbcd0a48-6ec6-4875-b78b-8fe9966d9697" />

## 캡슐화를 시도하면 기능에 대한 (의도) 이해를 높임

<img width="1003" height="432" alt="스크린샷 2025-10-14 오후 4 31 32" src="https://github.com/user-attachments/assets/383bba8c-353b-4871-b039-5f0316c45234" />

## 캡슐화를 위한 규칙

캡슐화 하고 싶다고 해서 자동으로 캡슐화 되는게 아님
그래서 보통 캡슐화를 위한 규칙 두가지를 제시를 함

1. 데이터를 달라하지 말고 해달라고 하기
2. 디미터의 법칙
    - 메서드에서 생성한 객체의 메서드만 호출
    - 파라미터로 받은 객체의 메서드만 호출
    - 필드로 참조하는 객체의 메서드만 호출
  <img width="886" height="202" alt="스크린샷 2025-10-14 오후 4 38 17" src="https://github.com/user-attachments/assets/9c412d60-124e-4f45-a8f7-340db7aa87cd" />

# 4. ⭐️ 다형성과 추상화 ⭐️


# 5. 상속보단 조립


# 6. 기능과 책임 분리


# 7. 의존과 DI
